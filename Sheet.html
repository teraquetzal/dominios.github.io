<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Hoja SRD 5.2.1</title>
    <script src="https://unpkg.com/@owlbear-rodeo/sdk@latest/dist/obr.js"></script>
    <style>
        body { font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; background: #2c2f33; color: white; padding: 10px; box-sizing: border-box; }
        .grid { display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 8px; margin-bottom: 15px; }
        .stat-box { background: #23272a; padding: 5px; border-radius: 5px; text-align: center; border: 1px solid #7289da; }
        .stat-box label { font-size: 0.65rem; color: #99aab5; display: block; text-transform: uppercase; margin-bottom: 2px;}
        input { width: 100%; box-sizing: border-box; background: transparent; border: none; border-bottom: 1px solid #444; color: white; text-align: center; font-size: 1.1rem; padding: 2px; }
        input:focus { outline: none; border-bottom: 1px solid #7289da; }
        textarea { width: 100%; box-sizing: border-box; background: #23272a; color: white; border: 1px solid #444; border-radius: 4px; height: 120px; resize: vertical; padding: 5px; font-family: inherit;}
        h3 { border-bottom: 2px solid #7289da; padding-bottom: 5px; font-size: 1rem; margin-top: 5px; }
        #token-name { font-weight: bold; color: #7289da; }
        #no-selection { text-align: center; margin-top: 50px; color: #99aab5; }
    </style>
</head>
<body>

    <div id="no-selection">Selecciona un token para ver su hoja.</div>

    <div id="sheet" style="display: none;">
        <h3><span id="token-name"></span></h3>
        
        <div class="grid">
            <div class="stat-box"><label>FUE</label><input type="number" data-key="stats.str"></div>
            <div class="stat-box"><label>DES</label><input type="number" data-key="stats.dex"></div>
            <div class="stat-box"><label>CON</label><input type="number" data-key="stats.con"></div>
            <div class="stat-box"><label>INT</label><input type="number" data-key="stats.int"></div>
            <div class="stat-box"><label>SAB</label><input type="number" data-key="stats.wis"></div>
            <div class="stat-box"><label>CAR</label><input type="number" data-key="stats.cha"></div>
        </div>

        <div class="grid">
            <div class="stat-box"><label>PG Actual</label><input type="number" data-key="hp"></div>
            <div class="stat-box"><label>CA</label><input type="number" data-key="ac"></div>
            <div class="stat-box"><label>Iniciativa</label><input type="number" data-key="init"></div>
        </div>

        <h3>Rasgos y Equipo</h3>
        <textarea id="notes" data-key="notes" placeholder="Notas, hechizos, inventario..."></textarea>
    </div>

    <script>
        const ID_EXTENS_METADATA = "com.mi-hoja-srd.data";
        let currentTokenId = null;

        OBR.onReady(async () => {
            // 1. Detectar cambios en la selección del jugador
            OBR.player.onChange((player) => {
                handleSelection(player.selection);
            });

            // 2. Detectar cambios en los items (Sincronización Multijugador)
            OBR.scene.items.onChange((items) => {
                if (!currentTokenId) return;
                const token = items.find(item => item.id === currentTokenId);
                // Si el token seleccionado cambió (por otro usuario), actualizamos la UI
                if (token && token.metadata[ID_EXTENS_METADATA]) {
                    updateUI(token.metadata[ID_EXTENS_METADATA]);
                }
            });
        });

        async function handleSelection(selection) {
            if (selection && selection.length > 0) {
                currentTokenId = selection[0];
                const items = await OBR.scene.items.getItems([currentTokenId]);
                const token = items[0];
                
                if (token) {
                    document.getElementById('sheet').style.display = 'block';
                    document.getElementById('no-selection').style.display = 'none';
                    document.getElementById('token-name').innerText = token.name;
                    
                    const metadata = token.metadata[ID_EXTENS_METADATA] || {};
                    updateUI(metadata);
                }
            } else {
                currentTokenId = null;
                document.getElementById('sheet').style.display = 'none';
                document.getElementById('no-selection').style.display = 'block';
            }
        }

        // Función para llenar los inputs sin disparar eventos de guardado
        function updateUI(metadata) {
            document.querySelectorAll('[data-key]').forEach(el => {
                // Solo actualizamos si el elemento NO tiene el foco (para no interrumpir escritura)
                if (document.activeElement !== el) {
                    const key = el.getAttribute('data-key');
                    const val = getNestedValue(metadata, key);
                    el.value = val !== undefined ? val : "";
                }
            });
        }

        // Guardar datos al escribir
        document.querySelectorAll('[data-key]').forEach(input => {
            input.addEventListener('input', async (e) => {
                if (!currentTokenId) return;
                const key = e.target.getAttribute('data-key');
                const value = e.target.value;

                // Optimización: Actualizar metadata localmente y luego enviar a OBR
                await OBR.scene.items.updateItems([currentTokenId], (items) => {
                    for (let item of items) {
                        if (!item.metadata[ID_EXTENS_METADATA]) {
                            item.metadata[ID_EXTENS_METADATA] = {};
                        }
                        setNestedValue(item.metadata[ID_EXTENS_METADATA], key, value);
                    }
                });
            });
        });

        // Utilidades
        function getNestedValue(obj, path) {
            return path.split('.').reduce((prev, curr) => prev && prev[curr], obj);
        }

        function setNestedValue(obj, path, value) {
            const keys = path.split('.');
            const lastKey = keys.pop();
            const lastObj = keys.reduce((prev, curr) => prev[curr] = prev[curr] || {}, obj);
            lastObj[lastKey] = value;
        }
    </script>
</body>
</html>
