<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Hoja SRD 5.2.1</title>
    <script src="https://unpkg.com/@owlbear-rodeo/sdk@latest/dist/obr.js"></script>
    <style>
        body { 
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; 
            background: #2c2f33; 
            color: white; 
            padding: 10px; 
            box-sizing: border-box; 
            /* Ocultamos el body por defecto para evitar parpadeos */
            opacity: 0; 
            transition: opacity 0.3s ease;
        }
        /* Solo mostramos el contenido si estamos en modo popover */
        body.ready { opacity: 1; }

        .grid { display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 8px; margin-bottom: 15px; }
        .stat-box { background: #23272a; padding: 5px; border-radius: 5px; text-align: center; border: 1px solid #7289da; }
        .stat-box label { font-size: 0.65rem; color: #99aab5; display: block; text-transform: uppercase; margin-bottom: 2px;}
        
        input { width: 100%; box-sizing: border-box; background: transparent; border: none; border-bottom: 1px solid #444; color: white; text-align: center; font-size: 1.1rem; padding: 2px; }
        input:focus { outline: none; border-bottom: 1px solid #7289da; background: rgba(114, 137, 218, 0.1); }
        /* Quitamos las flechas de los input number */
        input::-webkit-outer-spin-button, input::-webkit-inner-spin-button { -webkit-appearance: none; margin: 0; }
        input[type=number] { -moz-appearance: textfield; }

        textarea { width: 100%; box-sizing: border-box; background: #23272a; color: white; border: 1px solid #444; border-radius: 4px; height: 120px; resize: vertical; padding: 5px; font-family: inherit;}
        textarea:focus { outline: none; border-color: #7289da; }

        h3 { border-bottom: 2px solid #7289da; padding-bottom: 5px; font-size: 1rem; margin-top: 5px; color: #fff; }
        #token-name { font-weight: bold; color: #7289da; }
        #no-selection { text-align: center; margin-top: 50px; color: #99aab5; font-style: italic; }
    </style>
</head>
<body>

    <div id="no-selection">Selecciona un token para ver su hoja.</div>

    <div id="sheet" style="display: none;">
        <h3><span id="token-name"></span></h3>
        
        <div class="grid">
            <div class="stat-box"><label>FUE</label><input type="number" data-key="stats.str"></div>
            <div class="stat-box"><label>DES</label><input type="number" data-key="stats.dex"></div>
            <div class="stat-box"><label>CON</label><input type="number" data-key="stats.con"></div>
            <div class="stat-box"><label>INT</label><input type="number" data-key="stats.int"></div>
            <div class="stat-box"><label>SAB</label><input type="number" data-key="stats.wis"></div>
            <div class="stat-box"><label>CAR</label><input type="number" data-key="stats.cha"></div>
        </div>

        <div class="grid">
            <div class="stat-box"><label>PG</label><input type="number" data-key="hp"></div>
            <div class="stat-box"><label>CA</label><input type="number" data-key="ac"></div>
            <div class="stat-box"><label>Iniciativa</label><input type="number" data-key="init"></div>
        </div>

        <h3>Rasgos y Equipo</h3>
        <textarea id="notes" data-key="notes" placeholder="Notas, hechizos, inventario..."></textarea>
    </div>

    <script>
        const ID_EXTENS_METADATA = "com.mi-hoja-srd.data";
        const ACTION_ID = "com.mi-hoja-srd.action";
        let currentTokenId = null;

        OBR.onReady(async () => {
            // --- TRUCO: Detectar si estamos en el Popover o en Background ---
            const queryString = window.location.search;
            const urlParams = new URLSearchParams(queryString);
            const isPopover = urlParams.get('popover') === 'true';

            if (isPopover) {
                // MODO VISTA: Mostrar la hoja y activar listeners
                document.body.classList.add("ready");
                initSheetLogic();
            } else {
                // MODO FONDO: Crear el botón en la barra de herramientas
                OBR.tool.create({
                    id: ACTION_ID,
                    icons: [
                        {
                            icon: "https://img.icons8.com/ios-filled/50/ffffff/dungeons-and-dragons.png",
                            label: "Hoja SRD",
                        },
                    ],
                    onClick: (_, elementId) => {
                        OBR.popover.open({
                            id: "com.mi-hoja-srd.popover",
                            url: window.location.pathname + "?popover=true", // Abrimos este mismo archivo pero en modo popover
                            height: 500,
                            width: 320,
                            anchorElementId: elementId,
                        });
                    },
                });
            }
        });

        // --- LÓGICA DE LA HOJA ---
        function initSheetLogic() {
            // 1. Detectar cambios en la selección
            OBR.player.onChange((player) => {
                handleSelection(player.selection);
            });

            // 2. Sincronización Multijugador
            OBR.scene.items.onChange((items) => {
                if (!currentTokenId) return;
                const token = items.find(item => item.id === currentTokenId);
                if (token && token.metadata[ID_EXTENS_METADATA]) {
                    updateUI(token.metadata[ID_EXTENS_METADATA]);
                }
            });
            
            // Inicializar si ya hay algo seleccionado al abrir
            OBR.player.getSelection().then(selection => handleSelection(selection));
        }

        async function handleSelection(selection) {
            if (selection && selection.length > 0) {
                currentTokenId = selection[0];
                const items = await OBR.scene.items.getItems([currentTokenId]);
                const token = items[0];
                
                if (token && token.layer === "CHARACTER" || token.layer === "MOUNT") {
                    document.getElementById('sheet').style.display = 'block';
                    document.getElementById('no-selection').style.display = 'none';
                    document.getElementById('token-name').innerText = token.name;
                    
                    const metadata = token.metadata[ID_EXTENS_METADATA] || {};
                    updateUI(metadata);
                    return;
                }
            }
            // Si no hay selección válida
            currentTokenId = null;
            document.getElementById('sheet').style.display = 'none';
            document.getElementById('no-selection').style.display = 'block';
        }

        function updateUI(metadata) {
            document.querySelectorAll('[data-key]').forEach(el => {
                // No actualizamos si el usuario está escribiendo en ese momento
                if (document.activeElement !== el) {
                    const key = el.getAttribute('data-key');
                    const val = getNestedValue(metadata, key);
                    el.value = val !== undefined ? val : "";
                }
            });
        }

        // --- GUARDADO DE DATOS (OPTIMIZADO) ---
        
        async function saveData(key, value) {
            if (!currentTokenId) return;
            await OBR.scene.items.updateItems([currentTokenId], (items) => {
                for (let item of items) {
                    if (!item.metadata[ID_EXTENS_METADATA]) {
                        item.metadata[ID_EXTENS_METADATA] = {};
                    }
                    setNestedValue(item.metadata[ID_EXTENS_METADATA], key, value);
                }
            });
        }

        // Usamos 'change' para inputs numéricos (se guarda al perder foco o enter)
        document.querySelectorAll('input[data-key]').forEach(input => {
            input.addEventListener('change', (e) => {
                saveData(e.target.getAttribute('data-key'), e.target.value);
            });
        });

        // Usamos debounce para el textarea (notas)
        let timeout = null;
        document.querySelector('textarea').addEventListener('input', (e) => {
            clearTimeout(timeout);
            timeout = setTimeout(() => {
                saveData(e.target.getAttribute('data-key'), e.target.value);
            }, 500); // Espera 500ms después de dejar de escribir para guardar
        });

        // Utilidades
        function getNestedValue(obj, path) {
            return path.split('.').reduce((prev, curr) => prev && prev[curr], obj);
        }

        function setNestedValue(obj, path, value) {
            const keys = path.split('.');
            const lastKey = keys.pop();
            const lastObj = keys.reduce((prev, curr) => prev[curr] = prev[curr] || {}, obj);
            lastObj[lastKey] = value;
        }
    </script>
</body>
</html>